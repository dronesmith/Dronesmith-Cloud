# Forge Core

#Technologies
Forge is entirely MEAN stack, and as such is powered by the following technologies:

- Nodejs
- Express
- MongoDB
- AngularJS

In addition, it also uses the following:

- Bootstrap
- JQuery
- LESS
- Mongoose
- Redis
- PassportJS
- Angular UI

3D.js, TQuery, ace-ui, some others will no doubtedly be supported in the future.

# Architecture

Forge is architected as an ODM-driven Route-oriented Model-Controller with two-way binding views compiled client side. The following is an explanation of each layer.

### View Layer  
The view layer is standard HTML/CSS/Javascript. Behavior is bounded both ways, so changes in the Client Control layer will update this layer and vice-versa, via Angular's `$scope` injection. 

Bootstrap is used for basic templating, and Forge comes with its own bootstrap theme that is compiled whenever there is a change to it via a middlware. You can make adjustments to it in the `theme/css` directory. Everything in this directory is compiled with LESS, so if you want to define your own LESS stylesheets, define them in here as well.

Standard CSS should be defined in the `public/css` directory. You probably don't need to make any new files, here are the currently existing files:

**style.css** - All styling outside of bootstrap theme. Every new template has an id associate with it. **All styles must have #idname preceeding them for that corresponding template!** Further more, please follow the comments for grouping conventions. 

**animations.css** - Defines animations. Any animations should be grouped with the same conventions above.

**bootstrap.css** - This is an autogenerated file. Modify the less stuff if you want to change the bootstrap theme.

### Client Control Layer 

Talk about angular controllers/directives/filters/etc here

This layer involves controlling the behavior on the frontend. If you are not familiar with **AngularJS**, I suggest you spend some time learning/reading about it before beginning work here. 

We framework the client frontend with Angular. Forge spends a great deal of its functionality in the client side. It's not an ordinary web page, and shouldn't be treated as such. 

404s are handled by an angular-less html page. 500s handled gracefully by an angular page and **do show serverside errors.** 400s are intercepted by angular and shown as a red banner at the top of the page.

**Controllers** these control the behavior of a particular view. We are following the convention of one controller per view. This includes directives. Remember that in angular binding is bidirectional, and is resolved via the **$scope** data structure. Services can be used via dependency injection. Please structure your controllers in the follow order:

1. internal variables
2. internal functions
3. $scope variables (do **not** define them with ng-init).
4. $scope functions
5. event listeners (**$on**)
6. event emitters (**$emit**, **$broadcast**)

The controller hiearchey is as follows:

               AppCtrl 
                  |
      	      ForgeCtrl
                  |
        |---------|--------|
    Community  EeduLink  ModView
                           |
                      |----|----|      
              Additional mod controllers
              

**Services** are singletons that contain code that should be uniform to all controllers. Forge uses the ngResource mod to create RESTful endpoints of backend models. As such, if you need to communicate with the backend, please use the ngResource designed services to do so. Basic methods are `.get()/.query()` (GET {} or GET []), `.put()` (PUT {}), `.save()` (POST {} requires instantiation), and `.delete()` (DELETE). Forge comes with middlewares for resolving PUT/DELETE requests on crappy browsers that do not support them. Query strings are created automatically by ngResource.  

**Directives** are angular templates defined as custom HTML attribs/elements. Directives should be used in Forge whereever possible, and much of the code can already be refactored with them. 

**Filters** are functions that convert one form of input or output into another. Use filters to properly display internal data. 

Controllers currently communicate using events. Some events, like saving an app, or compiling code on Terminal, may take a while and should be deferred. We are currently looking into **WebWorkers** for this job. More to come on this as Forge matures.   

### Mod Packaging

The packaging and distribution of mods is still under development. For demo purposes, we are using a very rudimentary client side JQuery DOM injection. However, in the future, it will be better to either server templates (using ejs) from server side, or use some kind of specialized framework, like webpack. Any and all critiques are welcomed here.

### Routing Layer 

Servside endpoints are integrated via routes. Forge is built on top of **Express**, and as such, follows its routing format in similar fashion. Currently, most of the basic RESTful routing is contained in `routes/index.js`. All actual executable code should go in `lib/controllers`. The routes are strictly for API documentation and serve as RESTful endpoints, and middleware control. As Forge grows, this seemingly simple layer will no-doubt expand. Handling realtime websocket links is also an engineering issue that still needs to be discussed. 

Forge has 4 main APIs it employs:

**Community API**
Interacts with external web services and serves as a basic REST endpoint for the dronesmith community. This api is public. 

**Eedu Link API**
Handles connections with Eedu. The Eedu in question must "phone home" to Forge after it has been configured. During flights and missions, this must use a realtime connection system, like websockets. 

**Mod API**
The mods will be able to communicate with each other. It is currently a relatively lax event oriented system completely clientside, however due to the way mods will be loaded and packaged, this will probably make its way serverside. 

**Private REST API**
Simple API for Session/User management. It is special in the sense it reguarly syncs data to Forge.

### Server Control Layer

Server controllers handle Forge's behavior and interact with the model. Controllers are found ing `lib/controllers`. All controllers serve as behavior for implementing API actions from routes, and for interfacing with models. Since requests may not be completely immediately, to avoid callback hell, Forge is packaged with **Q**, which provides promises and futures, **async** for easily implementing asynchronous actions in code, and **underscore**, which provides functional programming interfaces.

MapReduce is your best friend, please abuse her.

### Model Layer

Forge uses **MongoDB** for most data, and **Redis** for storing sessions. All model data is contained in `lib/models`. **Mongoose** is used for `User` model, but other models may employ an ODM-less system and instead use **pmongo** (Promised mongo) and DAO for data. This pattern makes sense for things like mods, where the data schema is variable. A CDN service will probably be used for the distributing of mods in the future. 

Since users essentially have the freedom to store whatever they want on our backend, space-limiting middleware will need to be employed to keep the user from flooding our DB cluster. 

Below is a rough outline of the current Schema. 

		Session (Key-Value/Redis)
			=> Ref to User
			- Session Metadata 
		
		User (ODM/Mongoose)
			- Basic use account data
  			{ User Account information }
  			{ Syncable Forge Preferences }
  			[ Mods ]
  			[ Eedus ]
		
		Mod (DAO/PMongo)
			- Mod meta data
			{ Mixed Data \ depends on mod. This is syncable. }
		
		Eedu (ODM/Mongoose)
			Note that since this document is created by virtue of the server, it is automatically synced. 
			- Eedu meta data
			[Flights]
			[Missions]
			[Controllers]
			[Sensors]
			{Calibration}
			
		Flight ()
		
		Mission ()
		
		Controller ()
		
		Sensor ()
		
		Calibration ()
		

** If you have only used SQL, please remember MongoDB is not designed to be normalized. Calm your tits. **


# Running

	npm install
	grunt serve
	
Optionally, you can directly invoke the app with the following:

	node app.js
	
Runtime configuration settings can be edited in the `properties.json` file. In addition, `properies.[environment].json` allows you to create multiple configs per environment (for example, `properties.development.json`).

For development environemnts, to view your app, navigate to `localhost:3000` by default. 

For everything to work right, you will need to have the mongo daemon (`mongod`) and redis (`redis-server`) running, along with nodejs installed. 

# Contributing

Please read the architecture section before contributing! 

Contributing is simple. 

1. Assigned yourself an unassigned **FORG** ticket in Jira. 
2. git branch FORG-[ticketnumber] (eg, FORG-45)
3. Implement your work on this branch.
4. Make a pull request to master when you are ready
5. Geoff will do a code review of this pull req, and if everything looks good, will give the thumbs up and merge it. 

Please note that inactive branches will be purged from the remote on a bi-weekly basis. 


